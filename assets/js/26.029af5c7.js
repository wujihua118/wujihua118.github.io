(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{533:function(t,e,v){"use strict";v.r(e);var a=v(3),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("Vue基础知识整理")]),t._v(" "),v("h2",{attrs:{id:"响应式数据的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式数据的理解"}},[t._v("#")]),t._v(" 响应式数据的理解")]),t._v(" "),v("p",[t._v("数组和对象类型当值变化时如何劫持到。")]),t._v(" "),v("p",[t._v("对象内部通过defineReactive方法，使用 "),v("code",[t._v("Object.defineProperty")]),t._v(" 将属性进行劫持（只会劫持已存在的属性），数组则是通过重写数组方法来实现。")]),t._v(" "),v("blockquote",[v("p",[t._v("注意：多层对象是通过递归来实现劫持，vue3是使用proxy来实现响应式数据")])]),t._v(" "),v("h3",{attrs:{id:"补充"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[t._v("#")]),t._v(" 补充：")]),t._v(" "),v("p",[t._v("内部依赖收集是怎么做到的？")]),t._v(" "),v("p",[t._v("每个属性都有自己的dep属性，存放它所依赖的watcher。当属性变化后会通知自己对应的watcher去更新（每个对象类型自己本身也拥有一个dep属性）")]),t._v(" "),v("blockquote",[v("p",[t._v("性能优化相关：")]),t._v(" "),v("ul",[v("li",[t._v("对象层级过深，性能就会差")]),t._v(" "),v("li",[t._v("不需要响应数据的内容不要放在data中")]),t._v(" "),v("li",[v("code",[t._v("Object.freeze()")]),t._v(" 可以冻结数据")])])]),t._v(" "),v("h2",{attrs:{id:"vue如何检测数据变化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue如何检测数据变化"}},[t._v("#")]),t._v(" Vue如何检测数据变化")]),t._v(" "),v("p",[t._v("数组考虑性能原因没有用defineProperty对数组的每一项进行拦截，而是选择重写数组（push、shift、pop、splice、unshift、sort、reverse）方法进行重写。")]),t._v(" "),v("h3",{attrs:{id:"补充-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-2"}},[t._v("#")]),t._v(" 补充：")]),t._v(" "),v("p",[t._v("在vue中修改数组的索引和长度是无法监控到的。需要通过以上七种变异方法修改数组才会触发数组对应的watcher进行更新。数组中如果是对象数据类型也会进行递归劫持。")]),t._v(" "),v("blockquote",[v("p",[t._v("如果想更新索引更新数据怎么办？")]),t._v(" "),v("p",[t._v("可以通过 "),v("code",[t._v("Vue.$set()")]),t._v(" 来进行处理 => 核心内部用的是 splice 方法")])]),t._v(" "),v("h2",{attrs:{id:"vue中模版编译原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中模版编译原理"}},[t._v("#")]),t._v(" Vue中模版编译原理")]),t._v(" "),v("p",[t._v("如何将template转换成render函数（这里注意的是我们在开发时尽量不要使用template，因为将template转化成render方法需要在运行时进行编译操作会有性能损耗，同时引用带有compiler包的vue体积也会变大。默认.vue文件中的template处理是通过vue-loader来进行处理的而不是通过运行时的编译）")]),t._v(" "),v("ul",[v("li",[t._v("将template模版转换成AST语法树 - parserHTML")]),t._v(" "),v("li",[t._v("对静态语法做静态标记 - markUp")]),t._v(" "),v("li",[t._v("重新生成代码 - codeGen")])]),t._v(" "),v("blockquote",[v("p",[t._v("模版引擎的实现原理就是 "),v("code",[t._v("new Function")]),t._v(" + "),v("code",[t._v("with")]),t._v(" 来实现的")]),t._v(" "),v("p",[t._v("vue-loader中处理template属性主要靠的是 vue-template-compiler 模块")])]),t._v(" "),v("h2",{attrs:{id:"生命周期钩子如何实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子如何实现"}},[t._v("#")]),t._v(" 生命周期钩子如何实现")]),t._v(" "),v("p",[t._v("Vue的生命周期钩子就是回调函数而已，当创建组件实例的过程中会调用对应的钩子方法")]),t._v(" "),v("h3",{attrs:{id:"补充-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-3"}},[t._v("#")]),t._v(" 补充：")]),t._v(" "),v("p",[t._v("内部主要是使用callHook方法来调用的方法。核心是发布订阅模式，将钩子订阅好（内部采用数组的方式存储），在对应的阶段进行发布。")]),t._v(" "),v("h2",{attrs:{id:"vue-mixin-的使用场景和原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-mixin-的使用场景和原理"}},[t._v("#")]),t._v(" Vue.mixin 的使用场景和原理")]),t._v(" "),v("p",[t._v("Vue.mixin 的作用就是抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。如果混入的数据和本身组件中的数据冲突，会采用“就近原则”以组件的数据为准。")]),t._v(" "),v("h3",{attrs:{id:"补充-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-4"}},[t._v("#")]),t._v(" 补充：")]),t._v(" "),v("p",[t._v("mixin中有很多缺陷：")]),t._v(" "),v("ul",[v("li",[t._v("命名冲突问题")]),t._v(" "),v("li",[t._v("依赖问题")]),t._v(" "),v("li",[t._v("数据来源问题")])]),t._v(" "),v("p",[t._v("这里强调一下：mixin的数据是不会被共享的！")]),t._v(" "),v("h2",{attrs:{id:"nexttick-的使用场景和原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-的使用场景和原理"}},[t._v("#")]),t._v(" nextTick 的使用场景和原理")]),t._v(" "),v("p",[t._v("nextTick中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。原理就是异步方法（promise、mutationObserver、setImmediate、setTimeout）经常与事件环一起来问（宏任务和微任务）")]),t._v(" "),v("h3",{attrs:{id:"补充-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-5"}},[t._v("#")]),t._v(" 补充：")]),t._v(" "),v("p",[t._v("vue多次更新数据，最终会进行批处理更新。内部调用的就是nextTick实现了延迟更新，用户自定义的nextTick中的回调会被延迟到更新完成后调用，从而可以获取更新后的 DOM。")]),t._v(" "),v("h2",{attrs:{id:"vue为什么需要虚拟dom"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue为什么需要虚拟dom"}},[t._v("#")]),t._v(" Vue为什么需要虚拟DOM？")]),t._v(" "),v("p",[t._v("Virtual DOM就是用js对象来描述真实DOM，是对真实DOM的抽象。由于直接操作DOM性能低但是js层的操作效率高，可以将DOM操作转化为对象操作，最终通过diff算法比较差异进行更新DOM（减少了对真实DOM的操作）。虚拟DOM不依赖真实平台环境从而也可以实现跨平台。")]),t._v(" "),v("h3",{attrs:{id:"补充-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-6"}},[t._v("#")]),t._v(" 补充：")]),t._v(" "),v("p",[t._v("虚拟DOM的实现对象包含tag、data、children等属性对真实节点的描述。（本质上就是在js和DOM之间的一个缓存）")]),t._v(" "),v("h2",{attrs:{id:"vue中的-diff-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中的-diff-原理"}},[t._v("#")]),t._v(" Vue中的 diff 原理")]),t._v(" "),v("p",[t._v("Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式 + 双指针的方式进行比较。")]),t._v(" "),v("ul",[v("li",[t._v("先比较是否是相同节点")]),t._v(" "),v("li",[t._v("相同节点比较属性，并复用老节点")]),t._v(" "),v("li",[t._v("比较儿子节点，考虑老节点和新节点儿子的情况")]),t._v(" "),v("li",[t._v("优先比较：头头、尾尾、头尾、尾头")]),t._v(" "),v("li",[t._v("比较查找进行复用")])]),t._v(" "),v("blockquote",[v("p",[t._v("vue3中采用最长递增子序列实现diff算法")])]),t._v(" "),v("h2",{attrs:{id:"vue-set-方法如何实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-set-方法如何实现"}},[t._v("#")]),t._v(" Vue.set 方法如何实现")]),t._v(" "),v("p",[t._v("为什么 $set 可以触发更新？我们给对象和数组本身都增加了dep属性。当给对象新增不存在的属性则触发对象依赖的watcher去更新，当修改数组索引时我们调用数组本身的splice方法去更新数组。")]),t._v(" "),v("h2",{attrs:{id:"vue的生命周期钩子-一般在哪个钩子发起请求及原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期钩子-一般在哪个钩子发起请求及原因"}},[t._v("#")]),t._v(" Vue的生命周期钩子，一般在哪个钩子发起请求及原因")]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("beforeCreate")]),t._v(" 在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前调用。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("created")]),t._v(" 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测（data observer），属性和方法的运算，watcher/event事件回调。这里没有$el。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("beforeMount")]),t._v(" 在挂载开始之前被调用：相关的render函数首次被调用。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Mounted")]),t._v(" el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("beforeUpdate")]),t._v(" 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("updated")]),t._v(" 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("beforeDestroy")]),t._v(" 实例销毁之前调用。在这一步，实例完全仍然可用。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("destroyed")]),t._v(" Vue 实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。")])])]),t._v(" "),v("h3",{attrs:{id:"补充-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-7"}},[t._v("#")]),t._v(" 补充")]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("created")]),t._v(" 实例已经创建完成，因为它是最早触发的原因可以进行一些数据、资源的请求。（服务端渲染支持created方法）")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("mounted")]),t._v(" 实例已经挂载完成，可以进行一些DOM的操作")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("beforeUpdate")]),t._v(" 可以在这个钩子中进行一步地更改状态，这不会触发附加的重渲染过程。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("updated")]),t._v(" 可以执行依赖于DOM的操作。然而在大多是情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务端渲染期间不被调用。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("destroyed")]),t._v(" 可以执行一些优化操作，清除定时器，解除绑定事件。")])])]),t._v(" "),v("h2",{attrs:{id:"vue组件间传值的方式及之间的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件间传值的方式及之间的区别"}},[t._v("#")]),t._v(" Vue组件间传值的方式及之间的区别")]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("props")]),t._v(" 和 "),v("code",[t._v("$emit")]),t._v(" 父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来得到的。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("$parent")]),t._v(" 和 "),v("code",[t._v("$children")]),t._v(" 获取当前组件的父组件和当前组件的子组件")])]),t._v(" "),v("li",[v("p",[t._v("$attrs 和 "),v("code",[t._v("$listeners")]),t._v(" A => B => C vue2.4提供 "),v("code",[t._v("$attrs")]),t._v(" 和 "),v("code",[t._v("$listeners")]),t._v(" 来解决这个问题")])]),t._v(" "),v("li",[v("p",[t._v("父组件中通过 "),v("code",[t._v("provide")]),t._v(" 来提供变量，然后在子组件中通过 "),v("code",[t._v("inject")]),t._v(" 来注入变量。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("$refs")]),t._v(" 获取实例。")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("eventBus")]),t._v(" 平级组件数据传递，这种情况下可以使用中央事件总线的方式")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("vuex")]),t._v(" 状态管理")])])]),t._v(" "),v("h2",{attrs:{id:"attrs-是为了解决什么问题出现的以及应用场景-为什么provide-inject不能解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#attrs-是为了解决什么问题出现的以及应用场景-为什么provide-inject不能解决"}},[t._v("#")]),t._v(" $attrs 是为了解决什么问题出现的以及应用场景，为什么provide/inject不能解决")]),t._v(" "),v("p",[v("code",[t._v("$attrs")]),t._v(" 主要的作用就是实现批量数据传递，provide/inject更适合应用在插件中，主要是实现跨级数据传递。")]),t._v(" "),v("h2",{attrs:{id:"vue组件渲染流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件渲染流程"}},[t._v("#")]),t._v(" Vue组件渲染流程")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("父子组件渲染的先后顺序")])]),t._v(" "),v("li",[v("p",[t._v("组件是如何渲染到页面上的")])])]),t._v(" "),v("ul",[v("li",[t._v("在渲染父组件时会创建父组件的虚拟节点，其中可能包含子组件的标签")]),t._v(" "),v("li",[t._v("在创建虚拟节点时，获取组件的定义使用 "),v("code",[t._v("Vue.extend")]),t._v(" 生成组件的构造函数")]),t._v(" "),v("li",[t._v("将虚拟节点转化为真实节点时，会创建组件的实例并且调用组件的 "),v("code",[t._v("$mount")]),t._v(" 方法")]),t._v(" "),v("li",[t._v("所以组件的创建过程是先父后子")])]),t._v(" "),v("h2",{attrs:{id:"vue中组件的data为什么是一个函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中组件的data为什么是一个函数"}},[t._v("#")]),t._v(" Vue中组件的data为什么是一个函数")]),t._v(" "),v("p",[t._v("每次使用组件时都会对组件进行实例化操作，并且调用data函数返回一个对象作为组件的数据源。这样可以保证多个组件之间数据互不影响")]),t._v(" "),v("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" v-if 和 v-show 的区别")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("v-if 在编译的过程中会被转化成三元表达式，条件不满足时不渲染此节点")])]),t._v(" "),v("li",[v("p",[t._v("v-show 会被编译成指令，条件不满足时控制样式将对应的节点隐藏（内部其他指令依旧会继续执行）")])])]),t._v(" "),v("blockquote",[v("p",[t._v("频繁控制显示隐藏尽量不要使用 v-if，v-if 和 v-show 尽量不要连用")])]),t._v(" "),v("h2",{attrs:{id:"vue-use-是干什么的-原理是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-use-是干什么的-原理是什么"}},[t._v("#")]),t._v(" Vue.use 是干什么的？原理是什么？")]),t._v(" "),v("p",[v("code",[t._v("Vue.use")]),t._v(" 是用来使用插件的，我们可以在插件中扩展全局组件、指令和原型方法等。")]),t._v(" "),v("h2",{attrs:{id:"vue-router-有几种钩子函数-具体是什么及执行流程是什么样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-有几种钩子函数-具体是什么及执行流程是什么样的"}},[t._v("#")]),t._v(" vue-router 有几种钩子函数？具体是什么及执行流程是什么样的？")]),t._v(" "),v("p",[t._v("路由钩子的执行流程，钩子函数种类有：全局守卫、路由守卫、组件守卫")]),t._v(" "),v("h3",{attrs:{id:"完整的导航解析过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#完整的导航解析过程"}},[t._v("#")]),t._v(" 完整的导航解析过程：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("导航被触发")])]),t._v(" "),v("li",[v("p",[t._v("在失活的组件里调用 "),v("code",[t._v("beforeRouteLeave")]),t._v(" 守卫")])]),t._v(" "),v("li",[v("p",[t._v("调用全局的 "),v("code",[t._v("beforeEach")]),t._v(" 守卫")])]),t._v(" "),v("li",[v("p",[t._v("在重用的组件里调用 "),v("code",[t._v("beforeRouteUpdate")]),t._v(" 守卫（2.2+）")])]),t._v(" "),v("li",[v("p",[t._v("在路由配置里调用 "),v("code",[t._v("beforeEnter")])])]),t._v(" "),v("li",[v("p",[t._v("解析异步路由组件")])]),t._v(" "),v("li",[v("p",[t._v("在被激活的组件里调用 "),v("code",[t._v("beforeRouteEnter")])])]),t._v(" "),v("li",[v("p",[t._v("调用全局的 "),v("code",[t._v("beforeResolve")]),t._v(" 守卫（2.5+）")])]),t._v(" "),v("li",[v("p",[t._v("导航被确认")])]),t._v(" "),v("li",[v("p",[t._v("调用全局的 "),v("code",[t._v("afterEach")]),t._v(" 钩子")])]),t._v(" "),v("li",[v("p",[t._v("触发DOM更新")])]),t._v(" "),v("li",[v("p",[t._v("调用 "),v("code",[t._v("beforeRouteEnter")]),t._v(" 守卫传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入")])])]),t._v(" "),v("h2",{attrs:{id:"vue-router-两种模式的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-两种模式的区别"}},[t._v("#")]),t._v(" vue-router 两种模式的区别")]),t._v(" "),v("p",[t._v("hash模式、history模式")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("hash模式：hash + hashChange 兼容性好但是不美观")])]),t._v(" "),v("li",[v("p",[t._v("history模式：historyApi + popState 虽然美观，但是刷新会出现404，需要后端进行配置")])])]),t._v(" "),v("h2",{attrs:{id:"函数式组件的优势及原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数式组件的优势及原理"}},[t._v("#")]),t._v(" 函数式组件的优势及原理")]),t._v(" "),v("p",[t._v("函数式组件的特性：无状态、无生命周期、无this")]),t._v(" "),v("h2",{attrs:{id:"v-if-和-v-for-的优先级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-for-的优先级"}},[t._v("#")]),t._v(" v-if 和 v-for 的优先级")]),t._v(" "),v("p",[t._v("v-for 和 v-if 不要在同一个标签中使用，因为解析时先解析 v-for 再解析 v-if。如果遇到需要同时使用时可以考虑写成计算属性的方式")]),t._v(" "),v("p",[t._v("源码位置："),v("code",[t._v("src/compiler/codegen/index.js:55")])]),t._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("staticRoot "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("staticProcessed"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("genStatic")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" state"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("once "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("onceProcessed"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("genOnce")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" state"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("for "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("forProcessed"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("genFor")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" state"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// v-for")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("if "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ifProcessed"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("genIf")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("el"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" state"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// v-if")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("h2",{attrs:{id:"组件中写name选项有哪些好处及作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件中写name选项有哪些好处及作用"}},[t._v("#")]),t._v(" 组件中写name选项有哪些好处及作用")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("可以通过name找到对应的组件（递归组件）")])]),t._v(" "),v("li",[v("p",[t._v("可以通过name属性实现缓存功能（keep-alive）")])]),t._v(" "),v("li",[v("p",[t._v("可以通过name来识别组件（跨级组件通信时非常重要）")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);